# **Syncing-Battleship: Сервис синхронизации игровых состояний**

Syncing-Battleship — это легковесный микросервис синхронизации, разработанный для многопользовательских игр, таких как JPong. Он обеспечивает надежную и эффективную передачу данных между клиентами и сервером, а также поддерживает динамическую загрузку моделей данных для различных игр во время выполнения.

## **Особенности**

* **Динамическая загрузка моделей данных**: Сервис может загружать и использовать различные модели данных для синхронизации во время выполнения, что позволяет легко добавлять поддержку новых игр без перекомпиляции основного сервиса.  
* **Оптимизированная сетевая коммуникация**: Использует библиотеку Riptide Networking для эффективной передачи данных с поддержкой надежных и ненадежных сообщений.  
* **Четкое разделение ролей сообщений**: Сообщения классифицируются с помощью битовых флагов (MessageMark), что обеспечивает ясность и расширяемость протокола.  
* **Изоляция сессий**: Каждая игровая сессия изолирована, что повышает стабильность и отказоустойчивость.  
* **Гибкое управление сессиями**: SessionsRouter управляет созданием, присоединением и отключением игроков от игровых сессий.  
* **Контрольный интерфейс**: ControlOutlet предоставляет gRPC-интерфейс для управления сервисом (запуск новых сессий, завершение работы).

## **Архитектура**

Сервис состоит из следующих основных компонентов:

* **Program.cs**: Точка входа в приложение, настраивает и запускает основные хосты и роутеры.  
* **BehaviourLoader.cs**: Отвечает за динамическую загрузку DLL-файлов, содержащих реализации IDataBehaviour для конкретных игровых моделей.  
* **IDataBehaviour.cs (Syncing\_Battleship\_Common\_Typing)**: Интерфейс, который должны реализовывать все игровые модели данных. Определяет методы для получения состояния по умолчанию, создания полного сообщения о состоянии, применения обновлений и извлечения команд.  
* **MessageMark.cs (Syncing\_Battleship\_Common\_Typing)**: Перечисление с флагами, используемое для маркировки сообщений, определяя их роль (сервер), тип (обновление, команда, сессия, ошибка) и подтип.  
* **SessionsRouter.cs**: Управляет жизненным циклом игровых сессий. Отвечает за создание новых сессий, приветствие игроков и маршрутизацию сообщений в соответствующие сессии.  
* **Session.cs**: Представляет отдельную игровую сессию. Обрабатывает присоединение игроков, потребление сообщений (обновления состояния, команды) и отключения.  
* **WebsocketsHost.cs**: Хост для WebSocket-соединений, использующий Riptide Networking для обработки входящих и исходящих сообщений от клиентов.  
* **ControlOutlet.cs**: Предоставляет HTTP-интерфейс (предположительно gRPC, хотя в предоставленных файлах он не реализован полностью) для внешнего управления сервисом, например, для запуска новых игровых сессий.  
* **JPong (пример модуля)**: Пример реализации модели данных для игры JPong, демонстрирующий, как можно интегрировать новую игру:  
  * **JPongGameState.cs**: Определяет структуру состояния игры JPong и методы для применения частичных обновлений.  
  * **JPongDataBehaviour.cs**: Реализует IDataBehaviour для JPong, предоставляя логику для сериализации/десериализации состояния игры и обработки команд.

## **Как это работает**

1. **Запуск сервиса**: При запуске Program.cs инициализирует BehaviourLoader, который загружает указанную DLL с моделью данных для синхронизации (например, JPong.dll).  
2. **Создание сессий**: Внешний контроллер (через ControlOutlet) или другая логика может запросить создание новой игровой сессии через SessionsRouter. SessionsRouter создает новый экземпляр Session, используя загруженную модель данных.  
3. **Подключение клиентов**: Игровые клиенты подключаются к WebsocketsHost через WebSocket.  
4. **Присоединение к сессии**: Клиенты отправляют сообщение с запросом на присоединение к конкретной сессии, передавая sessionId и playerId. SessionsRouter проверяет запрос и, если он действителен, связывает соединение клиента с соответствующей сессией.  
5. **Синхронизация данных**:  
   * **Обновления состояния**: Игроки (или "источник истины" \- Source of Truth) отправляют сообщения об обновлении состояния игры. Session использует методы IDataBehaviour для применения этих обновлений к текущему состоянию игры и рассылает их всем подключенным игрокам.  
   * **Команды**: Игроки могут отправлять команды, которые обрабатываются IDataBehaviour и, при необходимости, рассылаются другим игрокам.  
6. **Отключение игроков**: При отключении игрока Session отслеживает его состояние и, после тайм-аута, удаляет игрока из сессии. Если сессия становится пустой, она завершается.

## **Запуск проекта (пример)**

Для запуска сервиса вам потребуется .NET 8.0 SDK.

1. **Сборка проекта**:  
   dotnet build

2. Запуск сервиса с моделью JPong:  
   Предполагается, что JPong.dll находится по пути Behavioural plugins/JPong/bin/Debug/net8.0/JPong.dll относительно исполняемого файла Syncing-Battleship.  
   dotnet run \--project Syncing\_Battleship "Behavioural plugins/JPong/bin/Debug/net8.0/JPong.dll" JPong.JPongDataBehaviour

   * "Behavioural plugins/JPong/bin/Debug/net8.0/JPong.dll": Путь к DLL-файлу, содержащему модель данных JPong.  
   * JPong.JPongDataBehaviour: Полное имя типа класса, реализующего IDataBehaviour в этой DLL.

## **Расширение**

Чтобы добавить поддержку новой игры:

1. **Создайте новый проект библиотеки C\#** (например, MyGame).  
2. **Добавьте ссылки** на Riptide и Syncing\_Battleship\_Common\_Typing.  
3. **Определите класс состояния игры** (например, MyGameState), который будет содержать все данные, необходимые для синхронизации.  
4. **Реализуйте интерфейс IDataBehaviour** в новом классе (например, MyGameDataBehaviour). В этом классе вы определите, как:  
   * Инициализировать состояние игры по умолчанию.  
   * Сериализовать полное состояние игры в сообщение Riptide.  
   * Применять частичные обновления состояния, полученные от клиентов.  
   * Извлекать и обрабатывать команды от клиентов.  
5. **Скомпилируйте проект** MyGame в DLL.  
6. **Запустите сервис Syncing-Battleship**, указав путь к вашей новой DLL и полное имя типа MyGameDataBehaviour в качестве аргументов командной строки.

## **Зависимости**

* **Riptide Networking**: Легковесная C\# библиотека для сетевой коммуникации в играх.  
* **Humanizer**: Библиотека для удобного форматирования данных (используется для TimeSpan).  
* **Microsoft.AspNetCore.App**: Для ControlOutlet (хотя gRPC-сервис не был полностью предоставлен).
